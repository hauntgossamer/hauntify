import tkinter as tk
from tkinter import filedialog
from tkinter import *
import pygame
import os
import sys
import random,time
from time import sleep
from io import BytesIO
from mutagen.mp3 import MP3
from mutagen.oggvorbis import OggVorbis
from PIL import Image, ImageTk, ImageDraw, ImageFont, ImageColor
import threading

# Define a custom border color to use throughout the app
border_color = '#111144'
# Global variable to hold the resize job ID for debouncing
resize_job = None
widgets_to_update = []
original_album_art_img = None 

def set_volume(val):
    """ Sets the volume of the music mixer. """
    volume = int(val) / 100
    pygame.mixer.music.set_volume(volume)

def update_song_progress():
    """ Updates the song progress bar and time label. """
    global current_song_length
    if pygame.mixer.music.get_busy() and current_song_length > 0:
        elapsed_time = pygame.mixer.music.get_pos() / 1000
        progress_bar.set(elapsed_time)
        
        # Format the time
        minutes = int(elapsed_time // 60)
        seconds = int(elapsed_time % 60)
        formatted_time = f"{minutes:02}:{seconds:02}"
        current_time_label.config(text=formatted_time)

    root.after(1000, update_song_progress)

def check_music_end():
    """ Checks for the end of the song and handles playback. """
    global current_song, shuffling, current_song_length
    for event in pygame.event.get():
        if event.type == SONG_END:
            skip_music()
    root.after(100, check_music_end)

def get_metadata(full_path):
    """ Reads metadata from a file and returns a dictionary. """
    metadata = {
        'title': os.path.basename(full_path).rsplit('.', 1)[0],
        'artist': "Unknown Artist",
        'album': "Unknown Album",
        'year': "Unknown Year",
        'length': 0,
        'album_art': None
    }
    
    try:
        if full_path.endswith(".mp3"):
            audio = MP3(full_path)
            if audio.tags:
                title_tag = audio.tags.get("TIT2")
                if title_tag:
                    metadata['title'] = str(title_tag[0])
                artist_tag = audio.tags.get("TPE1")
                if artist_tag:
                    metadata['artist'] = str(artist_tag[0])
                album_tag = audio.tags.get("TALB")
                if album_tag:
                    metadata['album'] = str(album_tag[0])
                year_tag = audio.tags.get("TDRL") or audio.tags.get("TDRC")
                if year_tag:
                    metadata['year'] = str(year_tag[0])
                
                album_art_data = audio.tags.get("APIC:")
                if album_art_data:
                    metadata['album_art'] = Image.open(BytesIO(album_art_data.data))
            metadata['length'] = audio.info.length

        elif full_path.endswith(".ogg"):
            audio = OggVorbis(full_path)
            if audio.tags:
                if 'title' in audio.tags:
                    metadata['title'] = audio.tags['title'][0]
                if 'artist' in audio.tags:
                    metadata['artist'] = audio.tags['artist'][0]
                if 'album' in audio.tags:
                    metadata['album'] = audio.tags['album'][0]
                if 'date' in audio.tags:
                    metadata['year'] = audio.tags['date'][0]
            metadata['length'] = audio.info.length

    except Exception as e:
        print(f"Error reading metadata from {full_path}: {e}")
    
    return metadata

def update_ui():
    """
    Applies the new font sizes and resizes album art to all widgets after a resize event.
    This function is now called only once the resize is complete.
    """
    global current_song, original_album_art_img
    new_width = root.winfo_width()
    new_height = root.winfo_height()
    
    # Calculate font size
    new_base_font_size = max(8, min(14, int(new_width / 80)))
    
    # Calculate album art size (based on the smaller of width or height)
    # The new size is a percentage of the smaller window dimension.
    new_album_art_size = int(min(new_width, new_height) * 0.5)
    
    # Clamp the size to be within a reasonable range
    new_album_art_size = max(100, new_album_art_size)
    
    # Update fonts for all widgets
    for font_name in fonts:
        if font_name == 'title':
            fonts[font_name].configure(size=int(new_base_font_size * 1.4))
        elif font_name == 'italic':
            fonts[font_name].configure(size=new_base_font_size)
        else:
            fonts[font_name].configure(size=new_base_font_size)
    
    # First, apply the font to all other widgets
    for widget, font_type in widgets_to_update:
        if widget != songlist:
            widget.config(font=fonts[font_type])

    # Now, handle the Listbox separately and aggressively
    current_selection_index = -1
    try:
        current_selection_index = songlist.curselection()[0]
    except IndexError:
        pass # No selection
    
    songlist.delete(0, 'end')
    for d in dicts:
        songlist.insert("end", d["display"])

    songlist.config(font=fonts['normal'])

    if current_selection_index != -1 and current_selection_index < songlist.size():
        songlist.selection_set(current_selection_index)
        songlist.see(current_selection_index) # Ensure the selection is visible

    # Resize and update the album art
    if original_album_art_img:
        resized_image = original_album_art_img.resize((new_album_art_size, new_album_art_size), Image.LANCZOS)
        new_photo_image = ImageTk.PhotoImage(resized_image)
        album_art_label.config(image=new_photo_image)
        album_art_label.image = new_photo_image
    else:
        resized_image = placeholder_img.resize((new_album_art_size, new_album_art_size), Image.LANCZOS)
        new_photo_image = ImageTk.PhotoImage(resized_image)
        album_art_label.config(image=new_photo_image)
        album_art_label.image = new_photo_image

def on_resize_event(event):
    """Schedules a UI update with a debounce to prevent flickering and lag."""
    global resize_job
    # Cancel any previous scheduled jobs
    if resize_job:
        root.after_cancel(resize_job)
    # Schedule a new job to run after a short delay
    resize_job = root.after(100, update_ui)

pygame.init()
SONG_END = pygame.USEREVENT+1
root = Tk()
root.title('Hauntify Music Player (Windows Edition)')
root.resizable(True, True)

path = ""
pygame.mixer.init()
dicts = []
songs = []
current_song = ""
paused = False
picked_music = False
shuffling = False
current_song_length = 0
original_album_art_img = None 

# Create a placeholder album art image for files with no embedded art.
placeholder_img = Image.new('RGB', (300, 300), color='#1a0129')
draw = ImageDraw.Draw(placeholder_img)
draw.rectangle([10, 10, 290, 290], outline="#ffffff", width=2)

try:
    text_font = ImageFont.truetype("Arial", 80)
except IOError:
    try:
        text_font = ImageFont.truetype("DejaVuSans", 80)
    except IOError:
        text_font = ImageFont.load_default()

text_to_draw = "ðŸŽ¶"
bbox = draw.textbbox((0, 0), text_to_draw, font=text_font)
text_width = bbox[2] - bbox[0]
text_height = bbox[3] - bbox[1]
text_x = (300 - text_width) / 2
text_y = (300 - text_height) / 2
draw.text((text_x, text_y), text_to_draw, fill="#ffffff", font=text_font)

global placeholder_album_art
placeholder_album_art = ImageTk.PhotoImage(placeholder_img)

# Get the path to the executable's directory for a consistent config file location
if getattr(sys, 'frozen', False):
    application_path = os.path.dirname(sys.executable)
else:
    application_path = os.path.dirname(os.path.abspath(__file__))

# Use the application path to define the config file path
config_file_path = os.path.join(application_path, ".last_dir.txt")

def shuffle(x):
    """ This is the custom shuffle method. It sorts a list based on a randomly generated key for each item. """
    shuffled_with_keys = [
        {"original": item, "sort_key": random.randint(0, 1000)}
        for item in x
    ]
    shuffled_with_keys.sort(key=lambda d: d["sort_key"])
    shuffled_list = [item["original"] for item in shuffled_with_keys]
    return shuffled_list

def load_songs_from_path(folder_path):
    """Clears and loads music from the given folder path."""
    global current_song, songs, dicts, picked_music, current_song_length
    
    if len(songs) > 0:
        songs = []
        dicts = []
        pygame.mixer.music.unload()
        songlist.delete(0, "end")
        songlist.selection_clear(0, "end")
    
    picked_music = True
    
    for root_dir, dirs, files in os.walk(folder_path):
        for f in files:
            full_path = os.path.join(root_dir, f)
            if(f.endswith(".mp3") or f.endswith(".ogg")):
                metadata = get_metadata(full_path)
                display_name = metadata['title']
                songs.append(f)
                dicts.append(dict(key=f, value=full_path, display=display_name))
                
    # Sort the dictionary list by display name
    dicts.sort(key=lambda d: d["display"].lower())
    
    # Clear and repopulate the listbox and songs list in the correct order
    songlist.delete(0, "end")
    songs.clear()
    for d in dicts:
        songs.append(d["key"])
        songlist.insert("end", d["display"])
    
    if songs:
        songlist.selection_set(0)
        current_song = songs[songlist.curselection()[0]]
        play_music()

def open_folder_dialog():
    """Opens a file dialog for the user to select a folder."""
    global config_file_path
    
    # Check for and read the last saved directory
    initial_dir = None
    if os.path.exists(config_file_path):
        with open(config_file_path, "r") as f:
            initial_dir = f.read().strip()
    
    path = filedialog.askdirectory(initialdir=initial_dir)
    
    # If a path is selected, save it and load the music
    if path:
        with open(config_file_path, "w") as f:
            f.write(path)
        load_songs_from_path(path)

global resized_album_art_image

def play_music():
    """
    Loads and plays the selected music file. This function is called
    when a song is selected or playback is unpaused.
    """
    global current_song, paused, current_song_length, original_album_art_img
    if not paused:
        
        # Find the dictionary entry for the current song
        song_entry = [i for i in dicts if i["key"] == current_song][0]
        full_path = song_entry["value"]
        
        # Use the helper function to get all metadata at once
        metadata = get_metadata(full_path)
        
        # Load the song in the mixer
        pygame.mixer.music.load(full_path)
        pygame.mixer.music.play()
        pygame.mixer.music.set_endevent(SONG_END)
        songlist.selection_clear(0, "end")
        songlist.selection_set(songs.index(current_song))
        
        # Update UI with the retrieved metadata
        song_title_label.config(text=metadata['title'])
        artist_label.config(text=metadata['artist'])
        album_label.config(text=metadata['album'])
        year_label.config(text=metadata['year'])
        
        current_song_length = metadata['length']
        progress_bar.config(to=current_song_length)
        
        minutes = int(current_song_length // 60)
        seconds = int(current_song_length % 60)
        total_time_label.config(text=f"{minutes:02}:{seconds:02}")
        
        # Handle album art
        if metadata['album_art']:
            original_album_art_img = metadata['album_art'].copy()
        else:
            original_album_art_img = placeholder_img.copy()
            
        # Call the UI update function to resize the art for initial display
        update_ui()
            
    else:
        pygame.mixer.music.unpause()
        paused = False

def pause_music():
    """ Pauses the current music playback. """
    global paused
    pygame.mixer.music.pause()
    paused = True

def skip_music():
    """ Skips to the next song in the playlist. """
    global current_song, paused, shuffling
    try:
        songlist.selection_clear(0, "end")
        songlist.selection_set(songs.index(current_song) + 1)
        current_song = songs[songlist.curselection()[0]]
        play_music()
    except:
        if shuffling == False:
            songlist.selection_clear(0, "end")
            songlist.selection_set(0)
            current_song = songs[songlist.curselection()[0]]
            play_music()
        else:
            shuffle_music()

def back_music():
    """ Skips to the previous song in the playlist. """
    global current_song, paused, shuffling
    try:
        songlist.selection_clear(0, "end")
        songlist.selection_set(songs.index(current_song) - 1)
        current_song = songs[songlist.curselection()[0]]
        play_music()
    except:
        if shuffling == False:
            songlist.selection_clear(0, "end")
            songlist.selection_set("end")
            current_song = songs[-1]
            play_music()
        else:
            shuffle_music()

def shuffle_music():
    """ Shuffles the entire playlist and starts playback. """
    global songs, shuffling, current_song, dicts
    shuffling = True
    
    # Shuffle the list of dictionaries
    dicts = shuffle(dicts)
    
    # Update the listbox to reflect the new order
    songlist.delete(0, "end")
    songs.clear()
    for d in dicts:
        songs.append(d["key"])
        songlist.insert("end", d["display"])

    current_song = songs[0]
    songlist.selection_set(0)
    play_music()
    
def play_selected_music(event):
    """ Play the selected song from the listbox. """
    global current_song, songs
    selected_index = songlist.curselection()
    if selected_index:
        current_song = songs[selected_index[0]]
        play_music()

# The Menu widget now has its own background and foreground color
menubar = Menu(root, bg="#1a0129", fg="#ffffff")
root.config(menu=menubar, bg="#1a0129")

# Create a central dictionary of font objects to manage them easily
import tkinter.font as tkfont
fonts = {
    'normal': tkfont.Font(family="Helvetica", size=10),
    'title': tkfont.Font(family="Helvetica", size=14, weight="bold"),
    'italic': tkfont.Font(family="Helvetica", size=10, slant="italic")
}


# The dropdown menu is now explicitly themed to match the app
organize_menu = Menu(
    menubar,
    tearoff=False,
    bg="#1a0129",
    fg="#ffffff",
    activebackground="#5A4286",
    activeforeground="#ffffff",
    font=fonts['normal']
)
organize_menu.add_command(label='Select Folder', command=open_folder_dialog)
menubar.add_cascade(label="Add Songs", menu=organize_menu)

# Set up the main grid for the application
root.grid_rowconfigure(0, weight=1)
root.grid_rowconfigure(1, weight=0)
root.grid_columnconfigure(0, weight=1)

# Create a frame for the playlist and place it in the top half
playlist_frame = Frame(root, bg=root['bg'])
playlist_frame.grid(row=0, column=0, sticky='nsew')
# Configure the playlist frame to have two columns
playlist_frame.grid_columnconfigure(0, weight=1) # Left column (playlist)
playlist_frame.grid_columnconfigure(1, weight=1) # Right column (album art)
playlist_frame.grid_rowconfigure(0, weight=1)

# Updated Listbox with flat borders.
songlist = Listbox(
    playlist_frame,
    bg="black",
    fg="#ffffff",
    relief=FLAT,
    bd=0,
    highlightthickness=2,
    highlightbackground=border_color,
    selectbackground=border_color,
    selectforeground="#ffffff",
    font=fonts['normal']
)
songlist.grid(row=0, column=0, sticky='nsew', padx=10, pady=10)
songlist.bind("<Double-Button-1>", play_selected_music)

# Create a sub-frame for the album art and labels to align them correctly on the right
album_art_frame = Frame(playlist_frame, bg=root['bg'])
album_art_frame.grid(row=0, column=1, sticky='nsew')
album_art_frame.grid_rowconfigure(0, weight=1)
album_art_frame.grid_rowconfigure(1, weight=0)
album_art_frame.grid_rowconfigure(2, weight=0)
album_art_frame.grid_rowconfigure(3, weight=0)
album_art_frame.grid_rowconfigure(4, weight=0)
album_art_frame.grid_columnconfigure(0, weight=1)

album_art_label = Label(album_art_frame, bg="#1a0129", relief=FLAT)
album_art_label.grid(row=0, column=0, sticky='nsew')

# Song title label
song_title_label = Label(album_art_frame, text="No song playing", bg="#1a0129", fg="#ffffff", font=fonts['title'])
song_title_label.grid(row=1, column=0, pady=(0, 0))

# Artist label
artist_label = Label(album_art_frame, text="", bg="#1a0129", fg="#aaaaaa", font=fonts['normal'])
artist_label.grid(row=2, column=0, pady=(0, 0))

# New labels for album and year
album_label = Label(album_art_frame, text="", bg="#1a0129", fg="#aaaaaa", font=fonts['italic'])
album_label.grid(row=3, column=0, pady=(0, 0))

year_label = Label(album_art_frame, text="", bg="#1a0129", fg="#aaaaaa", font=fonts['italic'])
year_label.grid(row=4, column=0, pady=(0, 10), sticky='n')

# Create a frame for all controls and place it in the bottom half
controls_frame = Frame(root, bg=root['bg'])
controls_frame.grid(row=1, column=0, sticky='nsew', pady=(5, 10))
controls_frame.grid_rowconfigure(0, weight=1)
controls_frame.grid_rowconfigure(1, weight=1)
controls_frame.grid_rowconfigure(2, weight=1)
controls_frame.grid_columnconfigure(0, weight=1)


# Updated control frame with flat borders, now inside controls_frame
control_frame = Frame(
    controls_frame,
    bg=controls_frame['bg'],
    relief=FLAT,
    bd=0
)
control_frame.grid(row=0, column=0, sticky='nsew')
control_frame.grid_columnconfigure(0, weight=1)
control_frame.grid_columnconfigure(1, weight=1)
control_frame.grid_columnconfigure(2, weight=1)
control_frame.grid_columnconfigure(3, weight=1)
control_frame.grid_columnconfigure(4, weight=1)

# Use tk.PhotoImage to load images directly
play_image = tk.PhotoImage(file="./icons/play.png")
pause_image = tk.PhotoImage(file="./icons/pause.png")
shuffle_image = tk.PhotoImage(file="./icons/shuffle.png")
skip_image = tk.PhotoImage(file="./icons/skip.png")
back_image = tk.PhotoImage(file="./icons/back.png")


# Use initial sized images for button creation.
# `activebackground` changes the color when the button is pressed.
play_btn = Button(
    control_frame,
    image=play_image,
    bg="#1a0129",
    relief=RAISED,
    bd=2,
    highlightthickness=0,
    highlightbackground=border_color,
    highlightcolor=border_color,
    activebackground="#5A4286",
    command=play_music
)
shuffle_btn = Button(
    control_frame,
    image=shuffle_image,
    bg="#1a0129",
    relief=RAISED,
    bd=2,
    highlightthickness=0,
    highlightbackground=border_color,
    highlightcolor=border_color,
    activebackground="#5A4286",
    command=shuffle_music
)
skip_btn = Button(
    control_frame,
    image=skip_image,
    bg="#1a0129",
    relief=RAISED,
    bd=2,
    highlightthickness=0,
    highlightbackground=border_color,
    highlightcolor=border_color,
    activebackground="#5A4286",
    command=skip_music
)
back_btn = Button(
    control_frame,
    image=back_image,
    bg="#1a0129",
    relief=RAISED,
    bd=2,
    highlightthickness=0,
    highlightbackground=border_color,
    highlightcolor=border_color,
    activebackground="#5A4286",
    command=back_music
)
pause_btn = Button(
    control_frame,
    image=pause_image,
    bg="#1a0129",
    relief=RAISED,
    bd=2,
    highlightthickness=0,
    highlightbackground=border_color,
    highlightcolor=border_color,
    activebackground="#5A4286",
    command=pause_music
)

# Use a grid layout for the buttons
play_btn.grid(row=0, column=0, padx=7, pady=2, sticky='nsew')
pause_btn.grid(row=0, column=1, padx=7, pady=2, sticky='nsew')
back_btn.grid(row=0, column=2, padx=7, pady=2, sticky='nsew')
skip_btn.grid(row=0, column=3, padx=7, pady=2, sticky='nsew')
shuffle_btn.grid(row=0, column=4, padx=7, pady=2, sticky='nsew')

# New frame for all sliders and place it directly under the buttons
slider_frame = Frame(controls_frame, bg=controls_frame['bg'])
slider_frame.grid(row=1, column=0, sticky='nsew', pady=5)
# Make the middle column expandable
slider_frame.grid_columnconfigure(0, weight=0)
slider_frame.grid_columnconfigure(1, weight=1)
slider_frame.grid_columnconfigure(2, weight=0)

# Progress bar with updated colors
current_time_label = Label(slider_frame, text="00:00", bg=controls_frame['bg'], fg="#ffffff", font=fonts['normal'])
current_time_label.grid(row=0, column=0, sticky='w')

progress_bar = Scale(
    slider_frame,
    from_=0,
    to=100,
    orient=HORIZONTAL,
    bg="#1a0129",
    fg="#9F7AEA",
    troughcolor="#5A4286",
    sliderrelief=FLAT,
    bd=0,
    highlightthickness=0,
    showvalue=False,
    state=DISABLED
)
progress_bar.grid(row=0, column=1, sticky='ew')

total_time_label = Label(slider_frame, text="00:00", bg=controls_frame['bg'], fg="#ffffff", font=fonts['normal'])
total_time_label.grid(row=0, column=2, sticky='e')

# Label for volume slider
volume_label = Label(slider_frame, text="Volume", bg=controls_frame['bg'], fg="#ffffff", font=fonts['normal'])
volume_label.grid(row=1, column=1, sticky='ew')

# Volume slider with updated colors
volume_slider = Scale(
    slider_frame,
    from_=0,
    to=100,
    orient=HORIZONTAL,
    bg="#1a0129",
    fg="#9F7AEA",
    troughcolor="#5A4286",
    sliderrelief=FLAT,
    bd=0,
    highlightthickness=0,
    command=set_volume
)
volume_slider.set(50)
volume_slider.grid(row=2, column=1, sticky='ew', pady=(10, 0))

# Populate the list of widgets to update
widgets_to_update = [
    (songlist, 'normal'),
    (song_title_label, 'title'),
    (artist_label, 'normal'),
    (album_label, 'italic'),
    (year_label, 'italic'),
    (current_time_label, 'normal'),
    (total_time_label, 'normal'),
    (volume_label, 'normal')
]
# We also need to re-configure the menu's font explicitly
organize_menu.config(font=fonts['normal'])
menubar.config(font=fonts['normal'])

# Load the last folder's music on startup
if os.path.exists(config_file_path):
    with open(config_file_path, "r") as f:
        last_dir = f.read().strip()
        if last_dir and os.path.isdir(last_dir):
            load_songs_from_path(last_dir)
            if songs:
                shuffle_music()

check_music_end()
update_song_progress()

# The only thing left to do is to bind the font update to the mouse release event
root.bind("<Configure>", on_resize_event)
root.mainloop()

pygame.quit()
